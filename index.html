<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="description" content="Wind map.">
<title>Wind map</title>
<style>

* { margin: 0; padding: 0; }

body {font: 10pt "Helvetica Neue", Arial, Helvetica, sans-serif;}

html, #map {
    position: absolute;
    height: 100%;
    width: 100vw;
    padding: 0;
}

body > #sidebar {
            display: none;
}

</style>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
  integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
  crossorigin=""/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.css"/>
<link rel="stylesheet" href="dist/L.Control.MousePosition.css"/>
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
    integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
    crossorigin="">
</script>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.2.1/math.min.js></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-ajax/2.1.0/leaflet.ajax.min.js"></script>
<script src='dist/L.Control.MousePosition.js'></script>
<!--leaflet-velocity-->
<link rel="stylesheet" href="dist/leaflet-velocity.css" />
<script src="dist/leaflet-velocity.js"></script>
<!--leaflet-sidebar-v2-->
<script src="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.2.3/js/leaflet-sidebar.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.2.3/css/leaflet-sidebar.min.css" rel="stylesheet">
</head>

<body>

 <!-- optionally define the sidebar content via HTML markup -->
 <div id="sidebar" class="leaflet-sidebar collapsed">

  <!-- nav tabs -->
  <div class="leaflet-sidebar-tabs">
      <!-- top aligned tabs -->
      <ul role="tablist">
          <li><a href="#home" role="tab"><i class="fa fa-bars active"></i></a></li>
          <li><a href="#wind" role="tab"><i class="fa fa-wind active"></i></a></li>
          <li><a href="https://github.com/1oly/wind"><i class="fa-brands fa-github"></i></a></li>
          <li><a href="https://olly.dk"><i class="fa fa-home"></i></a></li>
      </ul>
  </div>

  <!-- panel content -->
  <div class="leaflet-sidebar-content">
      <div class="leaflet-sidebar-pane" id="home">
          <h1 class="leaflet-sidebar-header">
              Wind map
              <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
          </h1>
          <h2>About wind map</h2>
          <p>This wind map is made to show the current wind turbines and wind field in Denmark. 
            The estimated current power production of each wind turbine is shown by clicking a turbine.</p>
            <h3>Data sources</h3>
            <ul>
              <li>Basemap is courtesy of <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a> and <a href="https://carto.com/attributions">CARTO</a>. </li>
              <li>Wind data is from Harmonie forecast model run by <a href="https://www.dmi.dk">DMI</a> and <a href="https://opendatadocs.dmi.govcloud.dk/DMIOpenData">DMI Open Data</a>.</li>
              <li>Wind turbine data is from <a href="https://ens.dk/service/statistik-data-noegletal-og-kort/download-gis-filer">Energistyrelsen</a> (the Danish Energy Agency). Updated November 2025.</li>
              <li>Power curves are computed using a generic model in <a href="https://gitlab.windenergy.dtu.dk/TOPFARM/PyWake/">PyWake</a> and by clustering turbine data.</li>
          </ul>
          <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          <p><a href="https://visitorbadge.io/status?path=https%3A%2F%2Fwind.olly.dk"><img src="https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fwind.olly.dk&label=VISITORS&countColor=%23263759&style=flat-square" /></a></p>
      </div>
      <div class="leaflet-sidebar-pane" id="wind">
        <h1 class="leaflet-sidebar-header">
            Wind turbine
            <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
        </h1>
        <h3>Wind turbine specs*</h3>
        <ul style="list-style: none;">
        <li><b>Model:</b> <div class="manufacturer" style="display: inline"></div> (<div class="model" style="display: inline"></div>)</li>
        <li><b>Power:</b> <div class="power" style="display: inline"></div> MW.</li>
        <li><b>Rotor diameter:</b> <div class="rotor_diam" style="display: inline"></div> m.</li>
        <li><b>Hub height:</b> <div class="hub_height" style="display: inline"></div> m.</li>
        <li><b>Date connected:</b> <div class="date_connect" style="display: inline"></div></li>
        <li><b>Date decomissioned:</b> <div class="date_decom" style="display: inline"></div></li>
        </ul>
        <h3>Power production</h3>
        <p></p>
        <div id="chart" style="width:350px;height:200px;"></div>
        <p><i>* Data is taken directly from Energistyrelsen and not quality assured before displaying it here. Wrong infomation may occur.</i></p>
        <h3>Wind forecast</h3>
        <p></p>
        <b>Forecast time:</b> <div class="refDate" style="display: inline"></div> <div class="refTime" style="display: inline"></div>
        <div class="wind-profile">
          <div id="windProfileStatus" class="wind-profile-status">Select a turbine to view the wind profile.</div>
          <div id="windProfileChart" style="width:350px;height:200px;"></div>
        </div>
        <h3>Power curve</h3>
        <div class="power-curve">
          <div id="powerCurveStatus" class="wind-profile-status">Select a turbine to view the power curve.</div>
          <div id="powerCurveChart" style="width:350px;height:200px;"></div>
        </div>
    </div>
  </div>
</div>


<div id="map"></div>
<script>

var map = new L.Map('map',{ zoomControl: false })
map.attributionControl.addAttribution('<a href="https://confluence.govcloud.dk/display/FDAPI/Danish+Meteorological+Institute+-+Open+Data">&copy; DMI</a>');
var layerControl = L.control.layers().addTo(map);

var CartoDB_DarkMatterNoLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
	attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>, &copy; <a href="https://carto.com/attributions">CARTO</a>',
	subdomains: 'abcd',
	maxZoom: 20
}).addTo(map);

var windProfileChartEl = document.getElementById('windProfileChart');
var windProfileStatusEl = document.getElementById('windProfileStatus');
var powerCurveChartEl = document.getElementById('powerCurveChart');
var powerCurveStatusEl = document.getElementById('powerCurveStatus');
var WIND_PROFILE_HEIGHTS = ['10m','50m','100m','150m','250m','350m','450m'];
var windGridCache = {};
var windGridPromise = null;
var lastWindProfileRequestId = 0;
var powerCurvesPromise = null;
var powerCurveEntries = [];
var wtlyr = null;

function ensureWindGridsLoaded() {
  if (!windGridPromise) {
    windGridPromise = Promise.all(WIND_PROFILE_HEIGHTS.map(function(height) {
      return fetch('https://raw.githubusercontent.com/1oly/wind/main/script/wind' + height + '.json')
        .then(function(response) {
          if (!response.ok) {
            throw new Error('Failed to fetch wind data for ' + height);
          }
          return response.json();
        })
        .then(function(records) {
          windGridCache[height] = buildWindGrid(records);
        });
    })).catch(function(error) {
      console.error(error);
      windGridPromise = null;
      throw error;
    });
  }
  return windGridPromise;
}

function buildWindGrid(records) {
  var uRecord = records.find(function(record) { return record.header.parameterNumber === 2; });
  var vRecord = records.find(function(record) { return record.header.parameterNumber === 3; });
  if (!uRecord || !vRecord) {
    return null;
  }
  var header = uRecord.header;
  return {
    header: header,
    u: uRecord.data,
    v: vRecord.data,
    nx: header.nx,
    ny: header.ny,
    lo1: header.lo1,
    la1: header.la1,
    dx: header.dx,
    dy: header.dy
  };
}

function interpolateWindAt(grid, lon, lat) {
  if (!grid) return null;
  var i = (lon - grid.lo1) / grid.dx;
  var j = (grid.la1 - lat) / grid.dy;
  if (isNaN(i) || isNaN(j)) return null;
  if (i < 0 || j < 0 || i > grid.nx - 1 || j > grid.ny - 1) return null;
  var fi = Math.floor(i);
  var fj = Math.floor(j);
  var ci = Math.min(fi + 1, grid.nx - 1);
  var cj = Math.min(fj + 1, grid.ny - 1);
  var tx = i - fi;
  var ty = j - fj;

  function vectorAt(x, y) {
    var idx = y * grid.nx + x;
    var uVal = grid.u[idx];
    var vVal = grid.v[idx];
    if (uVal === null || vVal === null || typeof uVal === 'undefined' || typeof vVal === 'undefined') {
      return null;
    }
    return [uVal, vVal];
  }

  var g00 = vectorAt(fi, fj);
  var g10 = vectorAt(ci, fj);
  var g01 = vectorAt(fi, cj);
  var g11 = vectorAt(ci, cj);
  if (!g00 || !g10 || !g01 || !g11) return null;

  var rx = 1 - tx;
  var ry = 1 - ty;
  var a = rx * ry;
  var b = tx * ry;
  var c = rx * ty;
  var d = tx * ty;
  var u = g00[0] * a + g10[0] * b + g01[0] * c + g11[0] * d;
  var v = g00[1] * a + g10[1] * b + g01[1] * c + g11[1] * d;
  var speed = Math.sqrt(u * u + v * v);
  var direction = null;
  if (speed > 0) {
    direction = (Math.atan2(u, v) * 180 / Math.PI + 360) % 360;
  }
  return { u: u, v: v, speed: speed, direction: direction };
}

function updateWindProfileStatus(message) {
  if (windProfileStatusEl) {
    windProfileStatusEl.textContent = message || '';
  }
}

function updatePowerCurveStatus(message, allowHTML) {
  if (!powerCurveStatusEl) return;
  if (allowHTML) {
    powerCurveStatusEl.innerHTML = message || '';
  } else {
    powerCurveStatusEl.textContent = message || '';
  }
}

function ensurePowerCurvesLoaded() {
  if (!powerCurvesPromise) {
    powerCurvesPromise = fetch('https://raw.githubusercontent.com/1oly/wind/main/power_curves/power_curves.json')
      .then(function(response) {
        if (!response.ok) {
          throw new Error('Power curve file missing');
        }
        return response.json();
      })
      .then(function(data) {
        powerCurveEntries = Array.isArray(data.turbines) ? data.turbines : [];
        return powerCurveEntries;
      })
      .catch(function(error) {
        console.warn('Unable to load power curves', error);
        powerCurveEntries = [];
        powerCurvesPromise = null;
        throw error;
      });
  }
  return powerCurvesPromise;
}

function selectPowerCurve(capacityKw, hubHeight) {
  if (!powerCurveEntries.length || typeof capacityKw !== 'number') {
    return null;
  }
  var best = null;
  var bestScore = Infinity;
  for (var i = 0; i < powerCurveEntries.length; i++) {
    var entry = powerCurveEntries[i];
    var capDiff = Math.abs((entry.capacity_kw || 0) - capacityKw);
    var heightDiff = Math.abs((entry.hub_height_m || 0) - (hubHeight || 0));
    var score = capDiff + 0.1 * heightDiff;
    if (score < bestScore) {
      bestScore = score;
      best = entry;
    }
  }
  return best;
}

function interpolatePowerFromCurve(curve, windSpeed) {
  if (!curve || !Array.isArray(curve.ws) || !Array.isArray(curve.power_mw)) {
    return null;
  }
  var wsArr = curve.ws;
  var powerArr = curve.power_mw;
  if (windSpeed <= wsArr[0]) return powerArr[0];
  if (windSpeed >= wsArr[wsArr.length - 1]) return powerArr[powerArr.length - 1];
  for (var i = 0; i < wsArr.length - 1; i++) {
    var lowerWs = wsArr[i];
    var upperWs = wsArr[i + 1];
    if (windSpeed >= lowerWs && windSpeed <= upperWs) {
      var ratio = (windSpeed - lowerWs) / (upperWs - lowerWs || 1);
      return powerArr[i] + ratio * (powerArr[i + 1] - powerArr[i]);
    }
  }
  return null;
}

function interpolateSpeedAtHeight(profile, targetHeight) {
  if (!profile.length || typeof targetHeight !== 'number' || isNaN(targetHeight)) {
    return null;
  }
  if (targetHeight <= profile[0].height) {
    return profile[0].speed;
  }
  if (targetHeight >= profile[profile.length - 1].height) {
    return profile[profile.length - 1].speed;
  }
  for (var i = 0; i < profile.length - 1; i++) {
    var lower = profile[i];
    var upper = profile[i + 1];
    if (targetHeight >= lower.height && targetHeight <= upper.height) {
      var ratio = (targetHeight - lower.height) / (upper.height - lower.height || 1);
      return lower.speed + ratio * (upper.speed - lower.speed);
    }
  }
  return null;
}

function estimateTurbinePower(windSpeed, ratedPowerMw) {
  if (typeof windSpeed !== 'number' || isNaN(windSpeed) || typeof ratedPowerMw !== 'number' || isNaN(ratedPowerMw)) {
    return null;
  }
  var cutIn = 3;
  var rated = 12;
  var cutOut = 25;
  if (windSpeed < cutIn || windSpeed >= cutOut) {
    return 0;
  }
  if (windSpeed >= rated) {
    return ratedPowerMw;
  }
  var fraction = (windSpeed - cutIn) / (rated - cutIn);
  var powerFraction = Math.pow(Math.max(0, Math.min(1, fraction)), 3);
  return ratedPowerMw * powerFraction;
}

function plotWindProfileAt(lon, lat, hubHeight) {
  if (!windProfileChartEl) return Promise.resolve(null);
  var requestId = ++lastWindProfileRequestId;
  updateWindProfileStatus('Loading wind profile…');
  return ensureWindGridsLoaded().then(function() {
    if (requestId !== lastWindProfileRequestId) {
      return null;
    }
    var profile = [];
    WIND_PROFILE_HEIGHTS.forEach(function(height) {
      var grid = windGridCache[height];
      if (!grid) return;
      var result = interpolateWindAt(grid, lon, lat);
      if (result) {
        profile.push({
          height: parseInt(height, 10),
          speed: result.speed,
          direction: result.direction
        });
      }
    });
    profile.sort(function(a, b) { return a.height - b.height; });
    if (!profile.length) {
      Plotly.purge(windProfileChartEl);
      updateWindProfileStatus('No wind profile data available here.');
      return {profile: profile, hubSpeed: null};
    }
    var speeds = profile.map(function(p) { return p.speed; });
    var heights = profile.map(function(p) { return p.height; });
    var shapes = [];
    var annotations = [];
    if (typeof hubHeight === 'number' && !isNaN(hubHeight)) {
      shapes.push({
        type: 'line',
        xref: 'paper',
        yref: 'y',
        x0: 0,
        x1: 1,
        y0: hubHeight,
        y1: hubHeight,
        line: {
          color: '#888',
          width: 1,
          dash: 'dash'
        }
      });
      annotations.push({
        xref: 'paper',
        yref: 'y',
        x: 0.01,
        y: hubHeight,
        text: 'Hub height',
        showarrow: false,
        font: {size: 10, color: '#666'},
        yshift: 10,
        align: 'left'
      });
    }
    Plotly.newPlot(windProfileChartEl, [{
      x: speeds,
      y: heights,
      mode: 'lines+markers',
      name: 'Wind speed',
      hovertemplate: 'Height: %{y} m<br>Speed: %{x:.1f} m/s<extra></extra>'
    }], {
      margin: {l: 50, r: 10, t: 10, b: 35},
      xaxis: {title: 'Wind speed (m/s)'},
      yaxis: {title: 'Height (m)'},
      shapes: shapes,
      annotations: annotations
    }, {responsive: true, displayModeBar: false});
    updateWindProfileStatus('');
    var hubSpeed = interpolateSpeedAtHeight(profile, hubHeight);
    return {profile: profile, hubSpeed: hubSpeed};
  }).catch(function(error) {
    Plotly.purge(windProfileChartEl);
    updateWindProfileStatus('Failed to load wind profile data.');
    throw error;
  });
}

function renderPowerCurve(curveData, hubSpeed, ratedPowerMw) {
  if (!powerCurveChartEl) return;
  if (curveData && Array.isArray(curveData.ws) && Array.isArray(curveData.power_mw)) {
    var traces = [{
      x: curveData.ws,
      y: curveData.power_mw,
      mode: 'lines',
      name: curveData.name || 'Power curve',
      hovertemplate: 'Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
    }];
    var pointPower = null;
    if (typeof hubSpeed === 'number' && !isNaN(hubSpeed)) {
      pointPower = interpolatePowerFromCurve(curveData, hubSpeed);
      traces.push({
        x: [hubSpeed],
        y: [pointPower],
        mode: 'markers',
        name: 'Current wind',
        marker: {color: '#d62728', size: 8},
        hovertemplate: 'Current wind<br>Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
      });
      var link = '<a href="https://gitlab.windenergy.dtu.dk/TOPFARM/PyWake" target="_blank" rel="noopener">PyWake</a>';
      updatePowerCurveStatus(curveData.name ? 'Generic power curve ' + curveData.name + ' made with ' + link : '', true);
    } else {
      updatePowerCurveStatus('No hub-height wind speed available.');
    }
    Plotly.newPlot(powerCurveChartEl, traces, {
      margin: {l: 50, r: 10, t: 10, b: 40},
      xaxis: {title: 'Wind speed (m/s)'},
      yaxis: {title: 'Power (MW)'},
      showlegend: false
    }, {responsive: true, displayModeBar: false});
    return;
  }
  renderGenericPowerCurve(hubSpeed, ratedPowerMw);
}

function renderGenericPowerCurve(hubSpeed, ratedPowerMw) {
  if (!powerCurveChartEl) return;
  if (typeof ratedPowerMw !== 'number' || isNaN(ratedPowerMw) || ratedPowerMw <= 0) {
    Plotly.purge(powerCurveChartEl);
    updatePowerCurveStatus('No turbine capacity data available.');
    return;
  }
  var speeds = [];
  var powers = [];
  for (var speed = 0; speed <= 30; speed += 0.5) {
    speeds.push(Number(speed.toFixed(1)));
    powers.push(estimateTurbinePower(speed, ratedPowerMw));
  }
  var traces = [{
    x: speeds,
    y: powers,
    mode: 'lines',
    name: 'Generic power curve',
    hovertemplate: 'Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
  }];
  if (typeof hubSpeed === 'number' && !isNaN(hubSpeed)) {
    var currentPower = estimateTurbinePower(hubSpeed, ratedPowerMw);
    traces.push({
      x: [hubSpeed],
      y: [currentPower],
      mode: 'markers',
      name: 'Current wind',
      marker: {color: '#d62728', size: 8},
      hovertemplate: 'Current wind<br>Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
    });
    updatePowerCurveStatus('Generic power curve');
  } else {
    updatePowerCurveStatus('No hub-height wind speed available.');
  }
  Plotly.newPlot(powerCurveChartEl, traces, {
    margin: {l: 50, r: 10, t: 10, b: 40},
    xaxis: {title: 'Wind speed (m/s)'},
    yaxis: {title: 'Power (MW)'},
    showlegend: false
  }, {responsive: true, displayModeBar: false});
}

function getRad_wt(d) {
    return d < 1 ? 1:
           d**0.6;
}

function scaledRadius(capacity_mw) {
    var base = getRad_wt(capacity_mw);
    var zoom = map.getZoom() || 0;
    var zoomBoost = Math.max(0, zoom - 8);
    var factor = Math.max(0.4, Math.pow(1.25, zoomBoost));
    return base * factor;
}

function wt_style(feature) {
    var kap = feature.properties.capacity_kW/1000
    return {
        radius: scaledRadius(kap),
        fillColor: 'white',
        weight: 0.0,
        opacity: 0.0,
        fillOpacity: 0.5
    };
}

function onEachFeature(feature, layer) {
    if (feature.properties && feature.properties.type) {
        layer.on('click', function(e) {
          sidebar.open('wind');
          $(".model").html(feature.properties.type);
          $(".manufacturer").html(feature.properties.manufacturer);
          $(".power").html(feature.properties.capacity_kW/1000);
          $(".hub_height").html(feature.properties.hub_height_m);
          $(".rotor_diam").html(feature.properties.rotor_diam_m);
          (feature.properties.date_connect !== null) ? feature.properties.date_connect : '';
          $(".date_connect").html((feature.properties.date_connect !== null) ? feature.properties.date_connect.split('T')[0] : '');
          $(".date_decom").html((feature.properties.date_decom !== null) ? feature.properties.date_decom.split('T')[0] : '');
          //$(".wind_speed").html(getWindSpeed(e));
          getData(feature);
          var capacityMw = feature.properties.capacity_kW/1000;
          var capacityKw = feature.properties.capacity_kW;
          updatePowerCurveStatus('Loading power curve…');
          var profilePromise = plotWindProfileAt(e.latlng.lng, e.latlng.lat, feature.properties.hub_height_m);
          var curvePromise = ensurePowerCurvesLoaded().catch(function() {
            updatePowerCurveStatus('Power curve data unavailable, using generic curve.');
            return null;
          });
          Promise.all([profilePromise, curvePromise]).then(function(results) {
            var profileResult = results[0];
            if (!profileResult) return;
            var curve = selectPowerCurve(capacityKw, feature.properties.hub_height_m);
            renderPowerCurve(curve, profileResult.hubSpeed, capacityMw);
          }).catch(function() {
            if (powerCurveChartEl) {
              Plotly.purge(powerCurveChartEl);
            }
            updatePowerCurveStatus('Failed to load power curve data.');
          });
        });
      }
}

function getWindSpeed(e) {
  if ($('.leaflet-control-velocity').length > 0) {
    var velocityValue = $('.leaflet-control-velocity').text();
    }
  return velocityValue
}

function circleMarker(feature, latlng) {
    return L.circleMarker(latlng, wt_style(feature));
}

// WIND TURBINES
$.getJSON("https://raw.githubusercontent.com/1oly/wind/main/wt_2025jan.json", function(wt) {
  wtlyr = L.geoJSON(wt, {
    pointToLayer: circleMarker,
    onEachFeature: onEachFeature
  }).addTo(map);
  layerControl.addOverlay(wtlyr, 'Wind turbines');
  map.fitBounds(wtlyr.getBounds());
});

map.on('zoomend', function() {
  if (!wtlyr) return;
  wtlyr.eachLayer(function(layer) {
    var kap = layer.feature.properties.capacity_kW / 1000;
    layer.setStyle({ radius: scaledRadius(kap) });
  });
});

// WIND PARTICLES

$.getJSON("https://raw.githubusercontent.com/1oly/wind/main/script/wind10m.json", function(data) {
  var velocityLayer = L.velocityLayer({
    displayValues: true,
    displayOptions: {
      velocityType: "Wind",
      position: "bottomleft",
      emptyString: "No wind data",
    },
    data: data,
    maxVelocity: 25
  }).addTo(map);
  $(".refDate").html(data[0].header.refTime.substr(0, 10));
  $(".refTime").html(data[0].header.refTime.substr(11, 8));
  layerControl.addOverlay(velocityLayer, "Wind 10m");
});

var sidebar = L.control.sidebar({
    autopan: false,       // whether to maintain the centered map point when opening the sidebar
    closeButton: true,    // whether t add a close button to the panes
    container: 'sidebar', // the DOM container or #ID of a predefined sidebar container that should be used
    position: 'left',     // left or right
}).addTo(map);
 
function getData(d) {
  var data = [];
  const yearsN = [...Array(48)].map((_, i) => i+1977)
  const years = [...Array(48)].map((_, i) => `${i+1977}`)
  const keys = Object.keys(d.properties)
  filteredArray = keys.filter( function( el ) {
    return years.includes( el );
  } );
  
  for(i in filteredArray){
    k = d.properties[filteredArray[i]]
    if (k === null){
      v = 0.0
    }
    else {
      v = k/1000.0
    }
    data.push(v);
  }
  plot = document.getElementById('chart');
  Plotly.newPlot( plot, [{
  x: yearsN,
  y: data,
  type: 'bar'}], {
  xaxis: {title:{text:'Year'},font:{family:'Helvetica Neue',size:10}},
  yaxis: {title:{text:'MWh'},font:{family:'Helvetica Neue',size:10}},
  margin: {l:50,r:10, t: 20 ,b:30} },{responsive: true});
}

</script>
</body>
</html>
