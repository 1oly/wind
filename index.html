<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="description" content="Wind map.">
<title>Wind map</title>
<style>

* { margin: 0; padding: 0; }

body {font: 10pt "Helvetica Neue", Arial, Helvetica, sans-serif;}

html, #map {
    position: absolute;
    height: 100%;
    width: 100vw;
    padding: 0;
}

body > #sidebar {
            display: none;
}

.filter-range {
    margin-bottom: 12px;
}

.filter-range-display {
    font-size: 9pt;
    color: #ddd;
    margin-bottom: 6px;
}

.filter-range-sliders {
    position: relative;
    height: 30px;
    margin-top: 4px;
}

.filter-range-sliders input[type=range] {
    -webkit-appearance: none;
    appearance: none;
    position: absolute;
    left: 0;
    width: 100%;
    height: 30px;
    background: none;
    pointer-events: none;
}

.filter-range-sliders input[type=range]::-webkit-slider-runnable-track {
    height: 4px;
    border-radius: 4px;
    background: transparent;
}

.filter-range-sliders input[type=range]::-moz-range-track {
    height: 4px;
    border-radius: 4px;
    background: transparent;
}

.filter-range-sliders input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    pointer-events: auto;
    height: 14px;
    width: 14px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid #1f8ef1;
    margin-top: -5px;
}

.filter-range-sliders input[type=range]::-moz-range-thumb {
    pointer-events: auto;
    height: 14px;
    width: 14px;
    border-radius: 50%;
    background: #fff;
    border: 2px solid #1f8ef1;
}

.filter-range-track {
    position: absolute;
    left: 0;
    right: 0;
    top: 50%;
    height: 4px;
    margin-top: -2px;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.2);
}

.filter-range-track::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    border-radius: 4px;
}

.filter-group {
    margin-bottom: 10px;
}

.filter-group label {
    display: block;
    font-weight: 600;
    margin-bottom: 3px;
}

.filter-group select,
.filter-group input {
    width: 100%;
    padding: 4px;
    box-sizing: border-box;
    font-size: 10pt;
}

.filter-inline-inputs {
    display: flex;
    gap: 6px;
}

.filter-inline-inputs input {
    flex: 1;
}

.filter-actions {
    margin-top: 12px;
}

#applyFiltersBtn {
    background: #1f8ef1;
    color: #fff;
    border: none;
    border-radius: 3px;
    padding: 6px 12px;
    font-size: 10pt;
    cursor: pointer;
}

#applyFiltersBtn:disabled {
    background: #777;
    cursor: not-allowed;
}

.filter-results {
    margin-top: 10px;
    font-size: 9pt;
    color: #ddd;
}

.filter-stats {
    margin-top: 12px;
    padding: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.filter-stat-line {
    font-size: 9pt;
    margin-bottom: 6px;
}

.filter-histogram {
    width: 100%;
    height: 180px;
}

</style>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
  integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
  crossorigin=""/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.css"/>
<link rel="stylesheet" href="dist/L.Control.MousePosition.css"/>
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
    integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
    crossorigin="">
</script>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.2.1/math.min.js></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-ajax/2.1.0/leaflet.ajax.min.js"></script>
<script src='dist/L.Control.MousePosition.js'></script>
<!--leaflet-velocity-->
<link rel="stylesheet" href="dist/leaflet-velocity.css" />
<script src="dist/leaflet-velocity.js"></script>
<!--leaflet-sidebar-v2-->
<script src="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.2.3/js/leaflet-sidebar.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.2.3/css/leaflet-sidebar.min.css" rel="stylesheet">
</head>

<body>

 <!-- optionally define the sidebar content via HTML markup -->
 <div id="sidebar" class="leaflet-sidebar collapsed">

  <!-- nav tabs -->
  <div class="leaflet-sidebar-tabs">
      <!-- top aligned tabs -->
      <ul role="tablist">
          <li><a href="#home" role="tab"><i class="fa fa-bars active"></i></a></li>
          <li><a href="#wind" role="tab"><i class="fa fa-wind active"></i></a></li>
          <li><a href="#filters" role="tab"><i class="fa fa-filter"></i></a></li>
          <li><a href="https://github.com/1oly/wind"><i class="fa-brands fa-github"></i></a></li>
          <li><a href="https://olly.dk"><i class="fa fa-home"></i></a></li>
      </ul>
  </div>

  <!-- panel content -->
  <div class="leaflet-sidebar-content">
      <div class="leaflet-sidebar-pane" id="home">
          <h1 class="leaflet-sidebar-header">
              Wind map
              <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
          </h1>
          <h2>About wind map</h2>
          <p>This wind map is made to show the current wind turbines and wind field in Denmark. 
            The estimated current power production of each wind turbine is shown by clicking a turbine.</p>
            <h3>Data sources</h3>
            <ul>
              <li>Basemap is courtesy of <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a> and <a href="https://carto.com/attributions">CARTO</a>. </li>
              <li>Wind data is from Harmonie forecast model run by <a href="https://www.dmi.dk">DMI</a> and <a href="https://opendatadocs.dmi.govcloud.dk/DMIOpenData">DMI Open Data</a>.</li>
              <li>Wind turbine data is from <a href="https://ens.dk/service/statistik-data-noegletal-og-kort/download-gis-filer">Energistyrelsen</a> (the Danish Energy Agency). Updated November 2025.</li>
              <li>Power curves are computed using a generic model in <a href="https://gitlab.windenergy.dtu.dk/TOPFARM/PyWake/">PyWake</a> and by clustering turbine data.</li>
          </ul>
          <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          <p><a href="https://visitorbadge.io/status?path=https%3A%2F%2Fwind.olly.dk"><img src="https://api.visitorbadge.io/api/visitors?path=https%3A%2F%2Fwind.olly.dk&label=VISITORS&countColor=%23263759&style=flat-square" /></a></p>
      </div>
      <div class="leaflet-sidebar-pane" id="wind">
        <h1 class="leaflet-sidebar-header">
            Wind turbine
            <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
        </h1>
        <h3>Wind turbine specs*</h3>
        <ul style="list-style: none;">
        <li><b>Model:</b> <div class="manufacturer" style="display: inline"></div> (<div class="model" style="display: inline"></div>)</li>
        <li><b>Power:</b> <div class="power" style="display: inline"></div> MW.</li>
        <li><b>Rotor diameter:</b> <div class="rotor_diam" style="display: inline"></div> m.</li>
        <li><b>Hub height:</b> <div class="hub_height" style="display: inline"></div> m.</li>
        <li><b>Date connected:</b> <div class="date_connect" style="display: inline"></div></li>
        <li><b>Date decomissioned:</b> <div class="date_decom" style="display: inline"></div></li>
        </ul>
        <h3>Power production</h3>
        <p>When the turbine belongs to a wind farm, the displayed production typically reflects the farm's total output</p>      
        <div id="chart" style="width:350px;height:200px;"></div>
        <p><i>* Data is taken directly from Energistyrelsen and not quality assured before displaying it here. Wrong infomation may occur.</i></p>
        <h3>Wind forecast</h3>
        <p></p>
        <b>Forecast time:</b> <div class="refDate" style="display: inline"></div> <div class="refTime" style="display: inline"></div>
        <div class="wind-profile">
          <div id="windProfileStatus" class="wind-profile-status">Select a turbine to view the wind profile.</div>
          <div id="windProfileChart" style="width:350px;height:200px;"></div>
        </div>
        <h3>Power curve</h3>
        <div class="power-curve">
          <div id="powerCurveStatus" class="wind-profile-status">Select a turbine to view the power curve.</div>
          <div id="powerCurveChart" style="width:350px;height:200px;"></div>
        </div>
    </div>
    <div class="leaflet-sidebar-pane" id="filters">
      <h1 class="leaflet-sidebar-header">
          Filter turbines
          <span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span>
      </h1>
      <p>Filter the turbines by properties</p>
      <div class="filter-group">
        <label for="filterManufacturer">Manufacturer</label>
        <select id="filterManufacturer">
          <option value="">Any</option>
        </select>
      </div>
      <div class="filter-group">
        <label for="filterLocation">Location</label>
        <select id="filterLocation">
          <option value="">Any</option>
        </select>
      </div>
      <div class="filter-group">
        <label for="filterAuthority">Authority</label>
        <select id="filterAuthority">
          <option value="">Any</option>
        </select>
      </div>
      <div class="filter-group filter-range">
        <label>Capacity (kW)</label>
        <div class="filter-range-display" id="capacityRangeDisplay">Loading…</div>
        <div class="filter-range-sliders">
          <div class="filter-range-track" id="capacityRangeTrack"></div>
          <input type="range" id="filterCapacityMin" min="0" max="0" step="1">
          <input type="range" id="filterCapacityMax" min="0" max="0" step="1">
        </div>
      </div>
      <div class="filter-group filter-range">
        <label>Rotor diameter (m)</label>
        <div class="filter-range-display" id="rotorRangeDisplay">Loading…</div>
        <div class="filter-range-sliders">
          <div class="filter-range-track" id="rotorRangeTrack"></div>
          <input type="range" id="filterRotorMin" min="0" max="0" step="0.1">
          <input type="range" id="filterRotorMax" min="0" max="0" step="0.1">
        </div>
      </div>
      <div class="filter-group filter-range">
        <label>Hub height (m)</label>
        <div class="filter-range-display" id="hubRangeDisplay">Loading…</div>
        <div class="filter-range-sliders">
          <div class="filter-range-track" id="hubRangeTrack"></div>
          <input type="range" id="filterHubMin" min="0" max="0" step="0.1">
          <input type="range" id="filterHubMax" min="0" max="0" step="0.1">
        </div>
      </div>
      <div class="filter-group">
        <label>Date connected</label>
        <div class="filter-inline-inputs">
          <input type="date" id="filterDateConnectStart">
          <input type="date" id="filterDateConnectEnd">
        </div>
      </div>
      <div class="filter-group">
        <label for="filterStatus">Operational status</label>
        <select id="filterStatus">
          <option value="">Any</option>
          <option value="operational">In operation</option>
          <option value="decommissioned">Decommissioned</option>
        </select>
      </div>
      <div class="filter-actions">
        <button type="button" id="applyFiltersBtn" disabled>Show</button>
      </div>
      <div class="filter-stats">
        <div id="filterCapacitySum" class="filter-stat-line">Total capacity: –</div>
        <div id="filterCapacityHistogram" class="filter-histogram">Histogram available when turbines include capacity data.</div>
      </div>
      <div id="filterResults" class="filter-results">Loading turbine data…</div>
    </div>
  </div>
</div>


<div id="map"></div>
<script>

var map = new L.Map('map',{ zoomControl: false })
map.attributionControl.addAttribution('<a href="https://confluence.govcloud.dk/display/FDAPI/Danish+Meteorological+Institute+-+Open+Data">&copy; DMI</a>');
var CartoDB_DarkMatterNoLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
	attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>, &copy; <a href="https://carto.com/attributions">CARTO</a>',
	subdomains: 'abcd',
	maxZoom: 20
}).addTo(map);

var windProfileChartEl = document.getElementById('windProfileChart');
var windProfileStatusEl = document.getElementById('windProfileStatus');
var powerCurveChartEl = document.getElementById('powerCurveChart');
var powerCurveStatusEl = document.getElementById('powerCurveStatus');
var WIND_PROFILE_HEIGHTS = ['10m','50m','100m','150m','250m','350m','450m'];
var windGridCache = {};
var windGridPromise = null;
var lastWindProfileRequestId = 0;
var powerCurvesPromise = null;
var powerCurveEntries = [];
var wtlyr = null;
var allTurbineFeatures = [];
var filterManufacturerEl = document.getElementById('filterManufacturer');
var filterLocationEl = document.getElementById('filterLocation');
var filterAuthorityEl = document.getElementById('filterAuthority');
var filterCapacityMinEl = document.getElementById('filterCapacityMin');
var filterCapacityMaxEl = document.getElementById('filterCapacityMax');
var filterRotorMinEl = document.getElementById('filterRotorMin');
var filterRotorMaxEl = document.getElementById('filterRotorMax');
var filterHubMinEl = document.getElementById('filterHubMin');
var filterHubMaxEl = document.getElementById('filterHubMax');
var capacityRangeDisplayEl = document.getElementById('capacityRangeDisplay');
var rotorRangeDisplayEl = document.getElementById('rotorRangeDisplay');
var hubRangeDisplayEl = document.getElementById('hubRangeDisplay');
var capacityRangeTrackEl = document.getElementById('capacityRangeTrack');
var rotorRangeTrackEl = document.getElementById('rotorRangeTrack');
var hubRangeTrackEl = document.getElementById('hubRangeTrack');
var filterDateConnectStartEl = document.getElementById('filterDateConnectStart');
var filterDateConnectEndEl = document.getElementById('filterDateConnectEnd');
var filterStatusEl = document.getElementById('filterStatus');
var filterResultsEl = document.getElementById('filterResults');
var filterCapacitySumEl = document.getElementById('filterCapacitySum');
var filterHistogramEl = document.getElementById('filterCapacityHistogram');
var applyFiltersBtn = document.getElementById('applyFiltersBtn');
var RANGE_EPSILON = 1e-6;

if (applyFiltersBtn) {
  applyFiltersBtn.addEventListener('click', applyFilters);
}

function ensureWindGridsLoaded() {
  if (!windGridPromise) {
    windGridPromise = Promise.all(WIND_PROFILE_HEIGHTS.map(function(height) {
      return fetch('https://raw.githubusercontent.com/1oly/wind/main/script/wind' + height + '.json')
        .then(function(response) {
          if (!response.ok) {
            throw new Error('Failed to fetch wind data for ' + height);
          }
          return response.json();
        })
        .then(function(records) {
          windGridCache[height] = buildWindGrid(records);
        });
    })).catch(function(error) {
      console.error(error);
      windGridPromise = null;
      throw error;
    });
  }
  return windGridPromise;
}

function buildWindGrid(records) {
  var uRecord = records.find(function(record) { return record.header.parameterNumber === 2; });
  var vRecord = records.find(function(record) { return record.header.parameterNumber === 3; });
  if (!uRecord || !vRecord) {
    return null;
  }
  var header = uRecord.header;
  return {
    header: header,
    u: uRecord.data,
    v: vRecord.data,
    nx: header.nx,
    ny: header.ny,
    lo1: header.lo1,
    la1: header.la1,
    dx: header.dx,
    dy: header.dy
  };
}

function interpolateWindAt(grid, lon, lat) {
  if (!grid) return null;
  var i = (lon - grid.lo1) / grid.dx;
  var j = (grid.la1 - lat) / grid.dy;
  if (isNaN(i) || isNaN(j)) return null;
  if (i < 0 || j < 0 || i > grid.nx - 1 || j > grid.ny - 1) return null;
  var fi = Math.floor(i);
  var fj = Math.floor(j);
  var ci = Math.min(fi + 1, grid.nx - 1);
  var cj = Math.min(fj + 1, grid.ny - 1);
  var tx = i - fi;
  var ty = j - fj;

  function vectorAt(x, y) {
    var idx = y * grid.nx + x;
    var uVal = grid.u[idx];
    var vVal = grid.v[idx];
    if (uVal === null || vVal === null || typeof uVal === 'undefined' || typeof vVal === 'undefined') {
      return null;
    }
    return [uVal, vVal];
  }

  var g00 = vectorAt(fi, fj);
  var g10 = vectorAt(ci, fj);
  var g01 = vectorAt(fi, cj);
  var g11 = vectorAt(ci, cj);
  if (!g00 || !g10 || !g01 || !g11) return null;

  var rx = 1 - tx;
  var ry = 1 - ty;
  var a = rx * ry;
  var b = tx * ry;
  var c = rx * ty;
  var d = tx * ty;
  var u = g00[0] * a + g10[0] * b + g01[0] * c + g11[0] * d;
  var v = g00[1] * a + g10[1] * b + g01[1] * c + g11[1] * d;
  var speed = Math.sqrt(u * u + v * v);
  var direction = null;
  if (speed > 0) {
    direction = (Math.atan2(u, v) * 180 / Math.PI + 360) % 360;
  }
  return { u: u, v: v, speed: speed, direction: direction };
}

function updateWindProfileStatus(message) {
  if (windProfileStatusEl) {
    windProfileStatusEl.textContent = message || '';
  }
}

function updatePowerCurveStatus(message, allowHTML) {
  if (!powerCurveStatusEl) return;
  if (allowHTML) {
    powerCurveStatusEl.innerHTML = message || '';
  } else {
    powerCurveStatusEl.textContent = message || '';
  }
}

function ensurePowerCurvesLoaded() {
  if (!powerCurvesPromise) {
    powerCurvesPromise = fetch('https://raw.githubusercontent.com/1oly/wind/main/power_curves/power_curves.json')
      .then(function(response) {
        if (!response.ok) {
          throw new Error('Power curve file missing');
        }
        return response.json();
      })
      .then(function(data) {
        powerCurveEntries = Array.isArray(data.turbines) ? data.turbines : [];
        return powerCurveEntries;
      })
      .catch(function(error) {
        console.warn('Unable to load power curves', error);
        powerCurveEntries = [];
        powerCurvesPromise = null;
        throw error;
      });
  }
  return powerCurvesPromise;
}

function selectPowerCurve(capacityKw, hubHeight) {
  if (!powerCurveEntries.length || typeof capacityKw !== 'number') {
    return null;
  }
  var best = null;
  var bestScore = Infinity;
  for (var i = 0; i < powerCurveEntries.length; i++) {
    var entry = powerCurveEntries[i];
    var capDiff = Math.abs((entry.capacity_kw || 0) - capacityKw);
    var heightDiff = Math.abs((entry.hub_height_m || 0) - (hubHeight || 0));
    var score = capDiff + 0.1 * heightDiff;
    if (score < bestScore) {
      bestScore = score;
      best = entry;
    }
  }
  return best;
}

function interpolatePowerFromCurve(curve, windSpeed) {
  if (!curve || !Array.isArray(curve.ws) || !Array.isArray(curve.power_mw)) {
    return null;
  }
  var wsArr = curve.ws;
  var powerArr = curve.power_mw;
  if (windSpeed <= wsArr[0]) return powerArr[0];
  if (windSpeed >= wsArr[wsArr.length - 1]) return powerArr[powerArr.length - 1];
  for (var i = 0; i < wsArr.length - 1; i++) {
    var lowerWs = wsArr[i];
    var upperWs = wsArr[i + 1];
    if (windSpeed >= lowerWs && windSpeed <= upperWs) {
      var ratio = (windSpeed - lowerWs) / (upperWs - lowerWs || 1);
      return powerArr[i] + ratio * (powerArr[i + 1] - powerArr[i]);
    }
  }
  return null;
}

function interpolateSpeedAtHeight(profile, targetHeight) {
  if (!profile.length || typeof targetHeight !== 'number' || isNaN(targetHeight)) {
    return null;
  }
  if (targetHeight <= profile[0].height) {
    return profile[0].speed;
  }
  if (targetHeight >= profile[profile.length - 1].height) {
    return profile[profile.length - 1].speed;
  }
  for (var i = 0; i < profile.length - 1; i++) {
    var lower = profile[i];
    var upper = profile[i + 1];
    if (targetHeight >= lower.height && targetHeight <= upper.height) {
      var ratio = (targetHeight - lower.height) / (upper.height - lower.height || 1);
      return lower.speed + ratio * (upper.speed - lower.speed);
    }
  }
  return null;
}

function estimateTurbinePower(windSpeed, ratedPowerMw) {
  if (typeof windSpeed !== 'number' || isNaN(windSpeed) || typeof ratedPowerMw !== 'number' || isNaN(ratedPowerMw)) {
    return null;
  }
  var cutIn = 3;
  var rated = 12;
  var cutOut = 25;
  if (windSpeed < cutIn || windSpeed >= cutOut) {
    return 0;
  }
  if (windSpeed >= rated) {
    return ratedPowerMw;
  }
  var fraction = (windSpeed - cutIn) / (rated - cutIn);
  var powerFraction = Math.pow(Math.max(0, Math.min(1, fraction)), 3);
  return ratedPowerMw * powerFraction;
}

function plotWindProfileAt(lon, lat, hubHeight) {
  if (!windProfileChartEl) return Promise.resolve(null);
  var requestId = ++lastWindProfileRequestId;
  updateWindProfileStatus('Loading wind profile…');
  return ensureWindGridsLoaded().then(function() {
    if (requestId !== lastWindProfileRequestId) {
      return null;
    }
    var profile = [];
    WIND_PROFILE_HEIGHTS.forEach(function(height) {
      var grid = windGridCache[height];
      if (!grid) return;
      var result = interpolateWindAt(grid, lon, lat);
      if (result) {
        profile.push({
          height: parseInt(height, 10),
          speed: result.speed,
          direction: result.direction
        });
      }
    });
    profile.sort(function(a, b) { return a.height - b.height; });
    if (!profile.length) {
      Plotly.purge(windProfileChartEl);
      updateWindProfileStatus('No wind profile data available here.');
      return {profile: profile, hubSpeed: null};
    }
    var speeds = profile.map(function(p) { return p.speed; });
    var heights = profile.map(function(p) { return p.height; });
    var shapes = [];
    var annotations = [];
    if (typeof hubHeight === 'number' && !isNaN(hubHeight)) {
      shapes.push({
        type: 'line',
        xref: 'paper',
        yref: 'y',
        x0: 0,
        x1: 1,
        y0: hubHeight,
        y1: hubHeight,
        line: {
          color: '#888',
          width: 1,
          dash: 'dash'
        }
      });
      annotations.push({
        xref: 'paper',
        yref: 'y',
        x: 0.01,
        y: hubHeight,
        text: 'Hub height',
        showarrow: false,
        font: {size: 10, color: '#666'},
        yshift: 10,
        align: 'left'
      });
    }
    Plotly.newPlot(windProfileChartEl, [{
      x: speeds,
      y: heights,
      mode: 'lines+markers',
      name: 'Wind speed',
      hovertemplate: 'Height: %{y} m<br>Speed: %{x:.1f} m/s<extra></extra>'
    }], {
      margin: {l: 50, r: 10, t: 10, b: 35},
      xaxis: {title: 'Wind speed (m/s)'},
      yaxis: {title: 'Height (m)'},
      shapes: shapes,
      annotations: annotations
    }, {responsive: true, displayModeBar: false});
    updateWindProfileStatus('');
    var hubSpeed = interpolateSpeedAtHeight(profile, hubHeight);
    return {profile: profile, hubSpeed: hubSpeed};
  }).catch(function(error) {
    Plotly.purge(windProfileChartEl);
    updateWindProfileStatus('Failed to load wind profile data.');
    throw error;
  });
}

function renderPowerCurve(curveData, hubSpeed, ratedPowerMw) {
  if (!powerCurveChartEl) return;
  if (curveData && Array.isArray(curveData.ws) && Array.isArray(curveData.power_mw)) {
    var traces = [{
      x: curveData.ws,
      y: curveData.power_mw,
      mode: 'lines',
      name: curveData.name || 'Power curve',
      hovertemplate: 'Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
    }];
    var pointPower = null;
    if (typeof hubSpeed === 'number' && !isNaN(hubSpeed)) {
      pointPower = interpolatePowerFromCurve(curveData, hubSpeed);
      traces.push({
        x: [hubSpeed],
        y: [pointPower],
        mode: 'markers',
        name: 'Current wind',
        marker: {color: '#d62728', size: 8},
        hovertemplate: 'Current wind<br>Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
      });
      var link = '<a href="https://gitlab.windenergy.dtu.dk/TOPFARM/PyWake" target="_blank" rel="noopener">PyWake</a>';
      updatePowerCurveStatus(curveData.name ? 'Generic power curve ' + curveData.name + ' made with ' + link : '', true);
    } else {
      updatePowerCurveStatus('No hub-height wind speed available.');
    }
    Plotly.newPlot(powerCurveChartEl, traces, {
      margin: {l: 50, r: 10, t: 10, b: 40},
      xaxis: {title: 'Wind speed (m/s)'},
      yaxis: {title: 'Power (MW)'},
      showlegend: false
    }, {responsive: true, displayModeBar: false});
    return;
  }
  renderGenericPowerCurve(hubSpeed, ratedPowerMw);
}

function renderGenericPowerCurve(hubSpeed, ratedPowerMw) {
  if (!powerCurveChartEl) return;
  if (typeof ratedPowerMw !== 'number' || isNaN(ratedPowerMw) || ratedPowerMw <= 0) {
    Plotly.purge(powerCurveChartEl);
    updatePowerCurveStatus('No turbine capacity data available.');
    return;
  }
  var speeds = [];
  var powers = [];
  for (var speed = 0; speed <= 30; speed += 0.5) {
    speeds.push(Number(speed.toFixed(1)));
    powers.push(estimateTurbinePower(speed, ratedPowerMw));
  }
  var traces = [{
    x: speeds,
    y: powers,
    mode: 'lines',
    name: 'Generic power curve',
    hovertemplate: 'Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
  }];
  if (typeof hubSpeed === 'number' && !isNaN(hubSpeed)) {
    var currentPower = estimateTurbinePower(hubSpeed, ratedPowerMw);
    traces.push({
      x: [hubSpeed],
      y: [currentPower],
      mode: 'markers',
      name: 'Current wind',
      marker: {color: '#d62728', size: 8},
      hovertemplate: 'Current wind<br>Wind: %{x:.1f} m/s<br>Power: %{y:.2f} MW<extra></extra>'
    });
    updatePowerCurveStatus('Generic power curve');
  } else {
    updatePowerCurveStatus('No hub-height wind speed available.');
  }
  Plotly.newPlot(powerCurveChartEl, traces, {
    margin: {l: 50, r: 10, t: 10, b: 40},
    xaxis: {title: 'Wind speed (m/s)'},
    yaxis: {title: 'Power (MW)'},
    showlegend: false
  }, {responsive: true, displayModeBar: false});
}

function renderTurbineCollection(features, options) {
  if (wtlyr) {
    map.removeLayer(wtlyr);
    wtlyr = null;
  }
  var validFeatures = Array.isArray(features) ? features.filter(function(feature) {
    return feature && feature.geometry && feature.geometry.type === 'Point' && Array.isArray(feature.geometry.coordinates);
  }) : [];
  if (!validFeatures.length) {
    return 0;
  }
  wtlyr = L.geoJSON({
    type: 'FeatureCollection',
    features: validFeatures
  }, {
    pointToLayer: circleMarker,
    onEachFeature: onEachFeature
  }).addTo(map);
  var shouldFit = !options || options.fitBounds !== false;
  if (shouldFit) {
    var bounds = wtlyr.getBounds();
    if (bounds && typeof bounds.isValid === 'function' && bounds.isValid()) {
      var padding = options && typeof options.boundsPadding === 'number' ? options.boundsPadding : 0.15;
      map.fitBounds(bounds.pad(padding));
    }
  }
  return validFeatures.length;
}

function populateFilterOptions(features) {
  if (!Array.isArray(features) || !features.length) return;
  setSelectOptions(filterManufacturerEl, getUniqueValues(features, 'manufacturer'));
  setSelectOptions(filterLocationEl, getUniqueValues(features, 'location'));
  setSelectOptions(filterAuthorityEl, getUniqueValues(features, 'auth'));
  if (applyFiltersBtn) {
    applyFiltersBtn.disabled = false;
  }
  updateFilterResults('Choose any combination of manufacturer, location, size, capacity, dates, or status filters, then press Show to highlight matching turbines.');
}

function translateLocation(value) {
  if (value === 'HAV') return 'Offshore';
  if (value === 'LAND') return 'Onshore';
  return value;
}

function getUniqueValues(features, key) {
  var seen = {};
  var values = [];
  for (var i = 0; i < features.length; i++) {
    var props = features[i].properties || {};
    var rawValue = props[key];
    if (rawValue === null || typeof rawValue === 'undefined' || rawValue === '') {
      continue;
    }
    var normalized = String(rawValue);
    if (!Object.prototype.hasOwnProperty.call(seen, normalized)) {
      seen[normalized] = true;
      values.push(rawValue);
    }
  }
  values.sort(function(a, b) {
    var aStr = String(a).toLowerCase();
    var bStr = String(b).toLowerCase();
    if (aStr < bStr) return -1;
    if (aStr > bStr) return 1;
    return 0;
  });
  return values;
}

function setSelectOptions(selectEl, values) {
  if (!selectEl) return;
  selectEl.innerHTML = '';
  var defaultOpt = document.createElement('option');
  defaultOpt.value = '';
  defaultOpt.textContent = 'Any';
  selectEl.appendChild(defaultOpt);
  if (!Array.isArray(values)) return;
  values.forEach(function(value) {
    var translated = translateLocation(value);
    var option = document.createElement('option');
    option.value = String(value);
    option.textContent = String(translated);
    selectEl.appendChild(option);
  });
}

function updateFilterResults(message) {
  if (!filterResultsEl) return;
  filterResultsEl.textContent = message || '';
}

function createRangeFormatter(decimals, unit) {
  return function(value) {
    if (typeof value !== 'number' || isNaN(value)) return '—';
    return value.toLocaleString('da-DK', {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    }) + (unit ? ' ' + unit : '');
  };
}

function getNumericRange(features, key) {
  var min = Infinity;
  var max = -Infinity;
  if (Array.isArray(features)) {
    features.forEach(function(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var value = typeof props[key] === 'number' ? props[key] : parseFloat(props[key]);
      if (typeof value === 'number' && !isNaN(value)) {
        min = Math.min(min, value);
        max = Math.max(max, value);
      }
    });
  }
  if (!isFinite(min) || !isFinite(max)) {
    return null;
  }
  return {min: min, max: max};
}

function updateRangeTrack(minSlider, maxSlider, trackEl) {
  if (!trackEl || !minSlider || !maxSlider) return;
  var minVal = parseFloat(minSlider.value);
  var maxVal = parseFloat(maxSlider.value);
  var minLimit = parseFloat(minSlider.min);
  var maxLimit = parseFloat(minSlider.max);
  var range = maxLimit - minLimit;
  if (!isFinite(range) || range <= 0) {
    trackEl.style.background = '';
    return;
  }
  var startPercent = ((minVal - minLimit) / range) * 100;
  var endPercent = ((maxVal - minLimit) / range) * 100;
  trackEl.style.background = 'linear-gradient(to right, rgba(255,255,255,0.2) ' + startPercent + '%, #1f8ef1 ' + startPercent + '%, #1f8ef1 ' + endPercent + '%, rgba(255,255,255,0.2) ' + endPercent + '%)';
}

function configureRangeControl(minSlider, maxSlider, displayEl, trackEl, range, options) {
  if (!minSlider || !maxSlider || !range) {
    if (displayEl) displayEl.textContent = 'No data available';
    if (minSlider) minSlider.disabled = true;
    if (maxSlider) maxSlider.disabled = true;
    if (trackEl) trackEl.style.background = '';
    return;
  }
  var step = options && typeof options.step === 'number' ? options.step : 1;
  var formatter = options && typeof options.format === 'function' ? options.format : function(val) { return val; };
  minSlider.disabled = false;
  maxSlider.disabled = false;
  minSlider.min = range.min;
  minSlider.max = range.max;
  minSlider.step = step;
  maxSlider.min = range.min;
  maxSlider.max = range.max;
  maxSlider.step = step;
  minSlider.value = range.min;
  maxSlider.value = range.max;
  minSlider.dataset.fullMin = range.min;
  minSlider.dataset.fullMax = range.max;
  maxSlider.dataset.fullMin = range.min;
  maxSlider.dataset.fullMax = range.max;

  function renderDisplay() {
    if (!displayEl) return;
    var minVal = parseFloat(minSlider.value);
    var maxVal = parseFloat(maxSlider.value);
    if ((isNaN(minVal) || Math.abs(minVal - range.min) < RANGE_EPSILON) &&
        (isNaN(maxVal) || Math.abs(maxVal - range.max) < RANGE_EPSILON)) {
      displayEl.textContent = 'Any';
    } else {
      displayEl.textContent = formatter(minVal) + ' – ' + formatter(maxVal);
    }
    updateRangeTrack(minSlider, maxSlider, trackEl);
  }

  function handleInput(event) {
    var minVal = parseFloat(minSlider.value);
    var maxVal = parseFloat(maxSlider.value);
    if (minVal > maxVal) {
      if (event && event.target === minSlider) {
        maxSlider.value = minVal;
      } else if (event && event.target === maxSlider) {
        minSlider.value = maxVal;
      }
    }
    renderDisplay();
  }

  minSlider.addEventListener('input', handleInput);
  maxSlider.addEventListener('input', handleInput);
  renderDisplay();
}

function getActiveRangeSelection(minSlider, maxSlider) {
  var inactive = {min: NaN, max: NaN};
  if (!minSlider || !maxSlider) return inactive;
  var minVal = parseFloat(minSlider.value);
  var maxVal = parseFloat(maxSlider.value);
  var fullMin = parseFloat(minSlider.dataset.fullMin);
  var fullMax = parseFloat(maxSlider.dataset.fullMax);
  var activeMin = (!isNaN(minVal) && !isNaN(fullMin) && minVal > fullMin + RANGE_EPSILON) ? minVal : NaN;
  var activeMax = (!isNaN(maxVal) && !isNaN(fullMax) && maxVal < fullMax - RANGE_EPSILON) ? maxVal : NaN;
  return {min: activeMin, max: activeMax};
}

function initializeRangeControls(features) {
  var capacityRange = getNumericRange(features, 'capacity_kW');
  configureRangeControl(
    filterCapacityMinEl,
    filterCapacityMaxEl,
    capacityRangeDisplayEl,
    capacityRangeTrackEl,
    capacityRange,
    {step: 10, format: createRangeFormatter(0, 'kW')}
  );
  var rotorRange = getNumericRange(features, 'rotor_diam_m');
  configureRangeControl(
    filterRotorMinEl,
    filterRotorMaxEl,
    rotorRangeDisplayEl,
    rotorRangeTrackEl,
    rotorRange,
    {step: 0.1, format: createRangeFormatter(1, 'm')}
  );
  var hubRange = getNumericRange(features, 'hub_height_m');
  configureRangeControl(
    filterHubMinEl,
    filterHubMaxEl,
    hubRangeDisplayEl,
    hubRangeTrackEl,
    hubRange,
    {step: 0.1, format: createRangeFormatter(1, 'm')}
  );
}

function formatMegawatts(value) {
  if (typeof value !== 'number' || isNaN(value)) return '0';
  return value.toLocaleString('da-DK', {minimumFractionDigits: 1, maximumFractionDigits: 1});
}

function updateFilterStatistics(features) {
  if (!filterCapacitySumEl || !filterHistogramEl) return;
  var totalCapacityKw = 0;
  var capacityValuesMw = [];
  if (Array.isArray(features)) {
    features.forEach(function(feature) {
      var props = feature && feature.properties ? feature.properties : {};
      var cap = typeof props.capacity_kW === 'number' ? props.capacity_kW : parseFloat(props.capacity_kW);
      if (typeof cap === 'number' && !isNaN(cap)) {
        totalCapacityKw += cap;
        capacityValuesMw.push(cap / 1000);
      }
    });
  }
  var countDesc = capacityValuesMw.length === 1 ? 'turbine with data' : 'turbines with data';
  filterCapacitySumEl.textContent = 'Total capacity: ' + formatMegawatts(totalCapacityKw / 1000) + ' MW (' + capacityValuesMw.length + ' ' + countDesc + ')';
  if (!capacityValuesMw.length) {
    Plotly.purge(filterHistogramEl);
    filterHistogramEl.textContent = 'Histogram available when turbines include capacity data.';
    return;
  }
  filterHistogramEl.textContent = '';
  Plotly.newPlot(filterHistogramEl, [{
    x: capacityValuesMw,
    type: 'histogram',
    marker: {color: '#1f8ef1'}
  }], {
    margin: {l: 35, r: 10, t: 10, b: 35},
    xaxis: {title: 'Capacity (MW)', tickfont: {size: 10}},
    yaxis: {title: 'Turbines', tickfont: {size: 10}},
    bargap: 0.05
  }, {displayModeBar: false, responsive: true});
}

function getDateInputValue(inputEl) {
  if (!inputEl || !inputEl.value) return null;
  var date = new Date(inputEl.value);
  var time = date.getTime();
  return isNaN(time) ? null : time;
}

function parseFeatureDate(value) {
  if (!value) return null;
  if (value instanceof Date) {
    var timeFromDate = value.getTime();
    return isNaN(timeFromDate) ? null : timeFromDate;
  }
  if (typeof value === 'number') {
    return isNaN(value) ? null : value;
  }
  var parsed = new Date(value);
  var timestamp = parsed.getTime();
  if (!isNaN(timestamp)) {
    return timestamp;
  }
  if (typeof value === 'string') {
    var shortValue = value.split('T')[0];
    var parsedShort = new Date(shortValue);
    var shortTimestamp = parsedShort.getTime();
    if (!isNaN(shortTimestamp)) {
      return shortTimestamp;
    }
  }
  return null;
}

function hasDecommissionDate(value) {
  return !(value === null || typeof value === 'undefined' || value === '');
}

function applyFilters() {
  if (!allTurbineFeatures.length) {
    updateFilterResults('Wind turbine data is still loading. Please try again in a moment.');
    return;
  }
  var manufacturer = filterManufacturerEl ? filterManufacturerEl.value : '';
  var locationVal = filterLocationEl ? filterLocationEl.value : '';
  var authority = filterAuthorityEl ? filterAuthorityEl.value : '';
  var capacityRangeSelection = getActiveRangeSelection(filterCapacityMinEl, filterCapacityMaxEl);
  var minCap = capacityRangeSelection.min;
  var maxCap = capacityRangeSelection.max;
  var rotorRangeSelection = getActiveRangeSelection(filterRotorMinEl, filterRotorMaxEl);
  var minRotor = rotorRangeSelection.min;
  var maxRotor = rotorRangeSelection.max;
  var hubRangeSelection = getActiveRangeSelection(filterHubMinEl, filterHubMaxEl);
  var minHub = hubRangeSelection.min;
  var maxHub = hubRangeSelection.max;
  var startDate = getDateInputValue(filterDateConnectStartEl);
  var endDate = getDateInputValue(filterDateConnectEndEl);
  var status = filterStatusEl ? filterStatusEl.value : '';
  if (startDate && endDate && endDate < startDate) {
    var tmpDate = startDate;
    startDate = endDate;
    endDate = tmpDate;
  }
  var matches = allTurbineFeatures.filter(function(feature) {
    var props = feature.properties || {};
    if (manufacturer && props.manufacturer !== manufacturer) return false;
    if (locationVal && props.location !== locationVal) return false;
    if (authority && props.auth !== authority) return false;
    if (!isNaN(minCap) && (typeof props.capacity_kW !== 'number' || props.capacity_kW < minCap)) return false;
    if (!isNaN(maxCap) && (typeof props.capacity_kW !== 'number' || props.capacity_kW > maxCap)) return false;
     if (!isNaN(minRotor) && (typeof props.rotor_diam_m !== 'number' || props.rotor_diam_m < minRotor)) return false;
     if (!isNaN(maxRotor) && (typeof props.rotor_diam_m !== 'number' || props.rotor_diam_m > maxRotor)) return false;
     if (!isNaN(minHub) && (typeof props.hub_height_m !== 'number' || props.hub_height_m < minHub)) return false;
     if (!isNaN(maxHub) && (typeof props.hub_height_m !== 'number' || props.hub_height_m > maxHub)) return false;
     var dateConnectedTs = parseFeatureDate(props.date_connect);
     if (startDate && (dateConnectedTs === null || dateConnectedTs < startDate)) return false;
     if (endDate && (dateConnectedTs === null || dateConnectedTs > endDate)) return false;
     var decommissioned = hasDecommissionDate(props.date_decom);
     if (status === 'operational' && decommissioned) return false;
     if (status === 'decommissioned' && !decommissioned) return false;
    return true;
  });
  updateFilterStatistics(matches);
  if (!matches.length) {
    updateFilterResults('No turbines matched the selected filters.');
    renderTurbineCollection([], {fitBounds: false});
    return;
  }
  var matchesWithGeometry = matches.filter(function(feature) {
    return feature.geometry && feature.geometry.type === 'Point' && Array.isArray(feature.geometry.coordinates);
  });
  if (!matchesWithGeometry.length) {
    updateFilterResults(matches.length + ' turbine(s) matched the filters, but none have coordinates in the dataset.');
    renderTurbineCollection([], {fitBounds: false});
    return;
  }
  var shown = renderTurbineCollection(matchesWithGeometry, {fitBounds: true});
  if (matchesWithGeometry.length < matches.length) {
    var missing = matches.length - matchesWithGeometry.length;
    updateFilterResults('Showing ' + shown + ' turbine(s). ' + missing + ' additional match(es) have no coordinates and cannot be mapped.');
  } else {
    updateFilterResults('Showing ' + shown + ' turbine(s).');
  }
}

function getRad_wt(d) {
    return d < 1 ? 1:
           d**0.6;
}

function scaledRadius(capacity_mw) {
    var base = getRad_wt(capacity_mw);
    var zoom = map.getZoom() || 0;
    var zoomBoost = Math.max(0, zoom - 8);
    var factor = Math.max(0.4, Math.pow(1.25, zoomBoost));
    return base * factor;
}

function wt_style(feature) {
    var kap = feature.properties.capacity_kW/1000
    return {
        radius: scaledRadius(kap),
        fillColor: 'white',
        weight: 0.0,
        opacity: 0.0,
        fillOpacity: 0.5
    };
}

function onEachFeature(feature, layer) {
    if (feature.properties && feature.properties.type) {
        layer.on('click', function(e) {
          sidebar.open('wind');
          $(".model").html(feature.properties.type);
          $(".manufacturer").html(feature.properties.manufacturer);
          $(".power").html(feature.properties.capacity_kW/1000);
          $(".hub_height").html(feature.properties.hub_height_m);
          $(".rotor_diam").html(feature.properties.rotor_diam_m);
          (feature.properties.date_connect !== null) ? feature.properties.date_connect : '';
          $(".date_connect").html((feature.properties.date_connect !== null) ? feature.properties.date_connect.split('T')[0] : '');
          $(".date_decom").html((feature.properties.date_decom !== null) ? feature.properties.date_decom.split('T')[0] : '');
          //$(".wind_speed").html(getWindSpeed(e));
          getData(feature);
          var capacityMw = feature.properties.capacity_kW/1000;
          var capacityKw = feature.properties.capacity_kW;
          updatePowerCurveStatus('Loading power curve…');
          var profilePromise = plotWindProfileAt(e.latlng.lng, e.latlng.lat, feature.properties.hub_height_m);
          var curvePromise = ensurePowerCurvesLoaded().catch(function() {
            updatePowerCurveStatus('Power curve data unavailable, using generic curve.');
            return null;
          });
          Promise.all([profilePromise, curvePromise]).then(function(results) {
            var profileResult = results[0];
            if (!profileResult) return;
            var curve = selectPowerCurve(capacityKw, feature.properties.hub_height_m);
            renderPowerCurve(curve, profileResult.hubSpeed, capacityMw);
          }).catch(function() {
            if (powerCurveChartEl) {
              Plotly.purge(powerCurveChartEl);
            }
            updatePowerCurveStatus('Failed to load power curve data.');
          });
        });
      }
}

function getWindSpeed(e) {
  if ($('.leaflet-control-velocity').length > 0) {
    var velocityValue = $('.leaflet-control-velocity').text();
    }
  return velocityValue
}

function circleMarker(feature, latlng) {
    return L.circleMarker(latlng, wt_style(feature));
}

// WIND TURBINES
$.getJSON("https://raw.githubusercontent.com/1oly/wind/main/wt_2025jan.json", function(wt) {
  allTurbineFeatures = Array.isArray(wt.features) ? wt.features.slice() : [];
  populateFilterOptions(allTurbineFeatures);
  initializeRangeControls(allTurbineFeatures);
  updateFilterStatistics(allTurbineFeatures);
  var shown = renderTurbineCollection(allTurbineFeatures, {fitBounds: true});
  if (shown > 0) {
    updateFilterResults('Showing ' + shown + ' turbine(s). Adjust the filters and press Show to narrow the selection.');
  } else {
    updateFilterResults('Turbine data loaded, but none include coordinates to display on the map.');
  }
});

map.on('zoomend', function() {
  if (!wtlyr) return;
  wtlyr.eachLayer(function(layer) {
    var kap = layer.feature.properties.capacity_kW / 1000;
    layer.setStyle({ radius: scaledRadius(kap) });
  });
});

// WIND PARTICLES

$.getJSON("https://raw.githubusercontent.com/1oly/wind/main/script/wind10m.json", function(data) {
  var velocityLayer = L.velocityLayer({
    displayValues: true,
    displayOptions: {
      velocityType: "Wind",
      position: "bottomleft",
      emptyString: "No wind data",
    },
    data: data,
    maxVelocity: 25
  }).addTo(map);
  $(".refDate").html(data[0].header.refTime.substr(0, 10));
  $(".refTime").html(data[0].header.refTime.substr(11, 8));
});

var sidebar = L.control.sidebar({
    autopan: false,       // whether to maintain the centered map point when opening the sidebar
    closeButton: true,    // whether t add a close button to the panes
    container: 'sidebar', // the DOM container or #ID of a predefined sidebar container that should be used
    position: 'left',     // left or right
}).addTo(map);
 
function getData(d) {
  var data = [];
  const yearsN = [...Array(48)].map((_, i) => i+1977)
  const years = [...Array(48)].map((_, i) => `${i+1977}`)
  const keys = Object.keys(d.properties)
  filteredArray = keys.filter( function( el ) {
    return years.includes( el );
  } );
  
  for(i in filteredArray){
    k = d.properties[filteredArray[i]]
    if (k === null){
      v = 0.0
    }
    else {
      v = k/1000.0
    }
    data.push(v);
  }
  plot = document.getElementById('chart');
  Plotly.newPlot( plot, [{
  x: yearsN,
  y: data,
  type: 'bar'}], {
  xaxis: {title:{text:'Year'},font:{family:'Helvetica Neue',size:10}},
  yaxis: {title:{text:'MWh'},font:{family:'Helvetica Neue',size:10}},
  margin: {l:50,r:10, t: 20 ,b:30} },{responsive: true});
}

</script>
</body>
</html>
